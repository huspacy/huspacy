params desc:
    - batch_size: x minta után indul a backpropagation, tehát ha 100 a size, akkor 100 minta után (100 példa a fájlban vagyis sor)
    fogja állítani a súlyokat
    - epoch: hányszor menjen végig az adatokon (az összesen), tehát 2 epoch akkor kétszer fog végig menni az adatokon

    - ha 1000 betanítási példa van, és a batch_size 500, akkor 2 iterációt vesz igénybe 1 epoch teljesítéshez

    - hidden_width: rejtett rétegek hossza (?)
    - maxout_pieces: hány egyenes alkossa az aktivációs függvényt, minnél több egyenes, annál bonyolultabb függvény (kvázi tanítható)

    - dropout: elfelejtettünk adott %-nyi neuron-t így elérve, hogy jobb legyen az általánosító képessége
    - L2: túltanulás és alul tanulás elkerüléséhez jól működik
            https://miro.medium.com/max/1400/0*tATGj-F5jlQU80GE.png

    - patience: ennyi lépés után nincs változás, akkor áll le
    - max_steps: annyi a max lépés, ha eléri leáll


model_path: best_hyperparams
    components.ner.model.extra_state_tokens: true
    components.ner.model.hidden_width: 64
    components.ner.model.maxout_pieces: 3
    training.dropout: 0.5
    training.optimizer.L2: 0.1
    training.optimizer.learn_rate.initial_rate: 0.00005

    train and dev test -> bias or variance error


ner:
dropout: 0.5
L2: 0.1
tokens: true
hidden width: 64
maxout pieces: 3

tagger:
dropout: 0.3
L2: 0.001
top_k = 2

parser:
?


ötlet:
parseren kívül mindent UD+SZC
   - parsert meg akkor tesztelve csak a transformert tovább adva
   (kvázi mindent freeze-elni)
   - mindent az UD-n - > kuka: mindenhol ront


batch_size: done
tagger fine-tune done (senter nélkül)
parser: Biaffine parsers test, aztán mehet a parser sweep
(mindent sweepelni -> Gyuri seaborn-os scriptje)



Biaffine parser
parser:
https://github.com/explosion/spacy-experimental/blob/master/projects/biaffine_parser/configs/base-config.cfg


models for assemble:
tagger_lemma_4 (nincs még fine-tune)
parser_4 -> with (pretrainelt taggerre) tagger_lemma_4
pretrain_train_ner_patience_evalfreq (pretrainelt taggerrel) tagger_lemma_4 dev: 93.11 test: 92.40
**************
biaffine, senter ok modelhez
tagger_lemma_5 (inprog) fine-tuneolt (de valamiért rosszabbbak)
biaffine_sent (inprog) nincs még fine-tune és pretrain sem
pretrain_train_ner_patience_evalfreq (pretrainelt taggerrel) dev: 93.11 test: 92.40
**************
tagger_lemma_5
biaffine_sent_tagger_lemma_5
ner_merged-tagger_lemma_5


TODO:
  evaluate_conll script nem megy a biaffine parserre és így a biaffine-s assemble-re sem:
  tagger_lemma_4: there is a cycle in a sentence
  assemble, biaffine_parser: mutliple roots, próbáltam a make_it_valid scriptet is
  assemble_4 -nél (biaffine_sentes parser) a spacy eval-al elfogy a memória, nem tudom kiértékelni...


- a biaffine_sent-es parsert (-> belőle az assemble-t sem) nem tudom sehogy sem kiértékelni (spacy eval memoria elfogy, conllu-val multiple error)
    parser nélkül nem megy
- amikor kiértékelek bármelyikkel, akkor warningol, azt amit akkor is kiír, amikor tanítok valamit
    nincs pulloló a háló fölé rakva, whatever
- biaffine parser vagy assemble, amiben biaffine van, spacy eval-nál a kirtékelési osztályok random számok, és romlik a biaffine parser, mint az eredeti tanításnál
    más senter miatt kevesebb, parser labeljei mindegy
- mindent egybe tanítva (a Peti, Zsolti javított SZC modikkal) rosszabb minden eredmény
    eddig is szar volt, mert generálva vannak benne a cimkék (UD-n)



sima parser false corpussal
biafffina false corpussal

tagger false corpussal (morph check)

assemble, parserben tovább tanított senter check score -> Zsoltinak küldeni


---------------------------------------------------------------------------------------------


mindegyikre igaz: Mindegyiket hagytam tovább tanulni és nagyobb iterációkat hagytam, így első ránézésre jobbak lettek a számok.
batch_size-t ksiebbre (128, 256, ezek voltak a defaultok)
eval_frequency-t nagyobbra (1000)
patience-t nagyobbra (20000)

ner: fine-tune-olt, pretrainelt tagger-rel (kisebb volt a szórása a iterációknak, tehát ilyen 91-92 között mozgott, nélküle meg 89-92)
    dev: 93.11
    test: 92.40


tagger: Még nincs fine-tune (jelenleg fut), de elnézve a sweepeket nagyon max tizedes javulások lehetnek itt-ott.
    sents:
        dev: 100
        test: 100
    tag:
        dev: 98.31
        test: 98.20
    pos:
        dev: 98.22
        test: 98.01
    morph:
        dev: 96.32
        test: 96.84
    lemma:
        dev: 97.74
        test: 97.73

parser: Még nincs fine-tune, és még nincs tesztelve azzal, amit Zsolti talált Biaffine parser-rel, de Zsolti futtatása alapján jobbnak fog igérkezni.
        Illetve tesztelni fogom még hogy milyen, ha megkapja a tagger modelt alapnak (többit komponenst nem, mert azok csak romlanak.
    uas:
        dev: 91.27
        test: 91.39
    las:
        dev: 85.24
        test: 85.76

nlp framework
 - general intro
 - spacy
komponensek
adatbázisok
gépi tanulás
 - introduction
 - ...
 - deep learning
 - tok2vec
 - transformer
related work
komponensek algoritmikai kifejtése

eredmények
 - kiértékelési metrikák
 - tok2vec vs transformer
 - hyperparameter optimization
 - parser (biaffine)
 - ner (beamner)
    - diff (ipymarkup)
??? külön error analysis, ahol csinálunk pl tagging error analysis-t is, pl összehasonlítjuk, az pos tag-enkénti f értékeket
conclusion

nerkor 1.41 ??





nlp
miért transzformer
hogyan jutottunk el a transzformerig (larg)

korpuszok
SZC, UD, NerKor, SzegedNER, wiki trf-en futtatni

komponensek bemutatása:
morph
sents
pos
parser, transfer learning + ner, (multitasking)
lemma
ner, encode: CNN, BiLSTM, embed: character, word alakú

hyperparams (?)

larg-model
diff
transformer: (belseje)
parser: deafault és biaffine
ner: default, beam_ner

accuaries
ipymark




